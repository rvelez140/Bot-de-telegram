import os
import logging
import asyncio
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes, ConversationHandler
import yt_dlp
import re
import whisper
import subprocess
import json
import tempfile
from datetime import datetime, timedelta
from playwright.async_api import async_playwright

# Configuraci√≥n de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Token del bot (desde variable de entorno)
BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
DOWNLOAD_DIR = '/downloads'
WHISPER_MODEL = None  # Se carga bajo demanda

# L√≠mites de Telegram
MAX_FILE_SIZE = 2000 * 1024 * 1024  # 2GB en bytes
CHUNK_SIZE = 1900 * 1024 * 1024     # 1.9GB por parte (margen de seguridad)

# Asegurar que el directorio de descargas existe
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# Almacenar datos temporales de usuario (URL y tiempo de expiraci√≥n)
user_data_store = {}

# Almacenar cookies de X/Twitter por usuario
user_twitter_cookies = {}

# Almacenar cookies de YouTube por usuario
user_youtube_cookies = {}

# Estados para el ConversationHandler de login
WAITING_USERNAME, WAITING_PASSWORD = range(2)
WAITING_YT_EMAIL, WAITING_YT_PASSWORD = range(2, 4)

async def generate_twitter_cookies(username, password):
    """Genera cookies de X/Twitter usando Playwright"""
    try:
        async with async_playwright() as p:
            # Usar chromium con headless
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            )
            page = await context.new_page()

            # Ir a la p√°gina de login de X/Twitter
            await page.goto('https://twitter.com/i/flow/login', wait_until='networkidle', timeout=30000)
            await asyncio.sleep(2)

            # Esperar e ingresar username/email
            try:
                username_input = await page.wait_for_selector('input[autocomplete="username"]', timeout=10000)
                await username_input.fill(username)
                await asyncio.sleep(1)

                # Click en "Next"
                next_button = await page.wait_for_selector('button:has-text("Next"), button:has-text("Siguiente")', timeout=5000)
                await next_button.click()
                await asyncio.sleep(2)

                # Esperar e ingresar password
                password_input = await page.wait_for_selector('input[name="password"], input[type="password"]', timeout=10000)
                await password_input.fill(password)
                await asyncio.sleep(1)

                # Click en "Log in"
                login_button = await page.wait_for_selector('button[data-testid="LoginForm_Login_Button"]', timeout=5000)
                await login_button.click()
                await asyncio.sleep(3)

                # Esperar a que cargue la p√°gina principal (verificar que el login fue exitoso)
                try:
                    await page.wait_for_selector('[data-testid="primaryColumn"]', timeout=15000)
                except:
                    # Si no aparece el elemento esperado, puede que requiera verificaci√≥n adicional
                    pass

                # Obtener cookies
                cookies = await context.cookies()

                await browser.close()

                # Convertir cookies a formato Netscape
                cookies_txt = "# Netscape HTTP Cookie File\n"
                cookies_txt += "# This file was generated by the bot for user authentication\n\n"

                for cookie in cookies:
                    domain = cookie.get('domain', '')
                    flag = 'TRUE' if domain.startswith('.') else 'FALSE'
                    path = cookie.get('path', '/')
                    secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
                    expiration = str(int(cookie.get('expires', -1)))
                    name = cookie.get('name', '')
                    value = cookie.get('value', '')

                    cookies_txt += f"{domain}\t{flag}\t{path}\t{secure}\t{expiration}\t{name}\t{value}\n"

                return {
                    'success': True,
                    'cookies': cookies_txt,
                    'cookies_dict': cookies
                }

            except Exception as e:
                await browser.close()
                logger.error(f"Error durante el login: {str(e)}")
                return {
                    'success': False,
                    'error': f'Error durante el proceso de login: {str(e)}'
                }

    except Exception as e:
        logger.error(f"Error generando cookies: {str(e)}")
        return {
            'success': False,
            'error': f'Error al conectar con X/Twitter: {str(e)}'
        }

async def generate_youtube_cookies(email, password):
    """Genera cookies de YouTube usando Playwright"""
    try:
        async with async_playwright() as p:
            # Usar chromium con headless
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            )
            page = await context.new_page()

            # Ir a la p√°gina de login de YouTube
            await page.goto('https://accounts.google.com/signin/v2/identifier?service=youtube', wait_until='networkidle', timeout=30000)
            await asyncio.sleep(2)

            # Esperar e ingresar email
            try:
                email_input = await page.wait_for_selector('input[type="email"]', timeout=10000)
                await email_input.fill(email)
                await asyncio.sleep(1)

                # Click en "Next"
                next_button = await page.wait_for_selector('button:has-text("Next"), button:has-text("Siguiente"), #identifierNext', timeout=5000)
                await next_button.click()
                await asyncio.sleep(3)

                # Esperar e ingresar password
                password_input = await page.wait_for_selector('input[type="password"]', timeout=10000)
                await password_input.fill(password)
                await asyncio.sleep(1)

                # Click en "Next"
                password_next_button = await page.wait_for_selector('button:has-text("Next"), button:has-text("Siguiente"), #passwordNext', timeout=5000)
                await password_next_button.click()
                await asyncio.sleep(5)

                # Esperar a que cargue YouTube (verificar que el login fue exitoso)
                try:
                    await page.wait_for_url('https://www.youtube.com/**', timeout=20000)
                except:
                    # Puede que est√© en otra p√°gina de Google, ir a YouTube
                    await page.goto('https://www.youtube.com', wait_until='networkidle', timeout=15000)
                    await asyncio.sleep(2)

                # Obtener cookies
                cookies = await context.cookies()

                await browser.close()

                # Convertir cookies a formato Netscape
                cookies_txt = "# Netscape HTTP Cookie File\n"
                cookies_txt += "# This file was generated by the bot for YouTube authentication\n\n"

                for cookie in cookies:
                    domain = cookie.get('domain', '')
                    flag = 'TRUE' if domain.startswith('.') else 'FALSE'
                    path = cookie.get('path', '/')
                    secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
                    expiration = str(int(cookie.get('expires', -1)))
                    name = cookie.get('name', '')
                    value = cookie.get('value', '')

                    cookies_txt += f"{domain}\t{flag}\t{path}\t{secure}\t{expiration}\t{name}\t{value}\n"

                return {
                    'success': True,
                    'cookies': cookies_txt,
                    'cookies_dict': cookies
                }

            except Exception as e:
                await browser.close()
                logger.error(f"Error durante el login de YouTube: {str(e)}")
                return {
                    'success': False,
                    'error': f'Error durante el proceso de login: {str(e)}'
                }

    except Exception as e:
        logger.error(f"Error generando cookies de YouTube: {str(e)}")
        return {
            'success': False,
            'error': f'Error al conectar con Google/YouTube: {str(e)}'
        }

class VideoDownloader:
    def __init__(self):
        self.supported_platforms = {
            'tiktok': ['tiktok.com', 'vm.tiktok.com', 'vt.tiktok.com'],
            'youtube': ['youtube.com', 'youtu.be'],
            'twitter': ['twitter.com', 'x.com', 't.co'],
            'instagram': ['instagram.com']
        }
    
    def get_platform(self, url):
        """Detecta la plataforma del URL"""
        url_lower = url.lower()
        for platform, domains in self.supported_platforms.items():
            if any(domain in url_lower for domain in domains):
                return platform
        return None
    
    def split_video(self, filename, chunk_size=CHUNK_SIZE):
        """Divide un video en partes si es muy grande"""
        file_size = os.path.getsize(filename)
        
        if file_size <= MAX_FILE_SIZE:
            return [filename]
        
        # Calcular n√∫mero de partes necesarias
        num_parts = math.ceil(file_size / chunk_size)
        
        logger.info(f"Archivo de {file_size / (1024*1024):.2f}MB, dividiendo en {num_parts} partes")
        
        base_name = os.path.splitext(filename)[0]
        ext = os.path.splitext(filename)[1]
        
        parts = []
        
        try:
            import subprocess
            
            # Usar ffmpeg para dividir el video
            for i in range(num_parts):
                start_time = i * (chunk_size / (file_size / self.get_duration(filename)))
                part_filename = f"{base_name}_parte{i+1}de{num_parts}{ext}"
                
                cmd = [
                    'ffmpeg', '-i', filename,
                    '-ss', str(start_time),
                    '-t', str(chunk_size / (file_size / self.get_duration(filename))),
                    '-c', 'copy',
                    '-avoid_negative_ts', '1',
                    part_filename
                ]
                
                subprocess.run(cmd, check=True, capture_output=True)
                parts.append(part_filename)
            
            return parts
            
        except Exception as e:
            logger.error(f"Error dividiendo video: {e}")
            # Si falla, devolver archivo original
            return [filename]
    
    def get_duration(self, filename):
        """Obtiene la duraci√≥n del video en segundos"""
        try:
            import subprocess
            result = subprocess.run(
                ['ffprobe', '-v', 'error', '-show_entries', 'format=duration',
                 '-of', 'default=noprint_wrappers=1:nokey=1', filename],
                capture_output=True,
                text=True,
                check=True
            )
            return float(result.stdout.strip())
        except:
            return 3600  # Default 1 hora si no se puede obtener
    
    async def download_image(self, url, chat_id):
        """Descarga im√°genes"""
        output_path = os.path.join(DOWNLOAD_DIR, f'{chat_id}_%(title)s.%(ext)s')
        
        ydl_opts = {
            'format': 'best',
            'outtmpl': output_path,
            'quiet': False,
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            },
        }
        
        # Soporte para cuentas privadas (solo si cookies.txt existe)
        cookies_file = '/app/cookies.txt'
        if os.path.exists(cookies_file) and os.path.getsize(cookies_file) > 10:
            ydl_opts['cookiefile'] = cookies_file
        
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=True)
                filename = ydl.prepare_filename(info)
                
                # Si no existe con la extensi√≥n esperada, buscar variantes
                if not os.path.exists(filename):
                    base = os.path.splitext(filename)[0]
                    for ext in ['.jpg', '.jpeg', '.png', '.webp', '.gif']:
                        alt_filename = base + ext
                        if os.path.exists(alt_filename):
                            filename = alt_filename
                            break
                
                return {
                    'success': True,
                    'filename': filename,
                    'title': info.get('title', 'image'),
                    'type': 'image'
                }
        except Exception as e:
            logger.error(f"Error descargando imagen: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def download_video(self, url, chat_id, user_id=None):
        """Descarga el video usando yt-dlp"""
        output_path = os.path.join(DOWNLOAD_DIR, f'{chat_id}_%(title)s.%(ext)s')

        ydl_opts = {
            'format': 'best[ext=mp4]/best',
            'outtmpl': output_path,
            'quiet': False,
            'no_warnings': False,
            'extract_flat': False,
            'ignoreerrors': False,
            'nocheckcertificate': True,
            # Limitar tama√±o para Telegram (50MB)
            'max_filesize': 50 * 1024 * 1024,
            # Headers para evitar bloqueos
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-us,en;q=0.5',
                'Sec-Fetch-Mode': 'navigate',
            },
        }

        platform = self.get_platform(url)

        # Configuraciones espec√≠ficas por plataforma
        if platform == 'tiktok':
            ydl_opts['format'] = 'best[ext=mp4]/best'
            # TikTok espec√≠fico
            ydl_opts['extractor_args'] = {'tiktok': {'api_hostname': 'api22-normal-c-useast2a.tiktokv.com'}}
        elif platform == 'instagram':
            ydl_opts['format'] = 'best[ext=mp4]/best'
            # Instagram necesita cookies para cuentas privadas
        elif platform == 'youtube':
            ydl_opts['format'] = 'bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best'
            # Configuraci√≥n adicional para evitar detecci√≥n de bot en YouTube
            ydl_opts['extractor_args'] = {
                'youtube': {
                    'player_client': ['android', 'web'],
                    'skip': ['hls', 'dash']
                }
            }

            # Usar cookies del usuario si est√°n disponibles
            if user_id and user_id in user_youtube_cookies:
                # Crear archivo temporal de cookies para este usuario
                cookies_file = os.path.join(DOWNLOAD_DIR, f'youtube_cookies_{user_id}.txt')
                with open(cookies_file, 'w') as f:
                    f.write(user_youtube_cookies[user_id])
                ydl_opts['cookiefile'] = cookies_file
                logger.info(f"Usando cookies de usuario {user_id} para YouTube")
            else:
                # Intentar usar cookies si existe un archivo cookies.txt global
                cookies_file = '/app/cookies.txt'
                if os.path.exists(cookies_file) and os.path.getsize(cookies_file) > 10:
                    ydl_opts['cookiefile'] = cookies_file
        elif platform == 'twitter':
            # Configuraci√≥n espec√≠fica para Twitter/X
            ydl_opts['format'] = 'best[ext=mp4]/best'
            # A√±adir extractor args espec√≠ficos para Twitter
            ydl_opts['extractor_args'] = {
                'twitter': {
                    'api': ['syndication', 'graphql']
                }
            }

            # Usar cookies del usuario si est√°n disponibles
            if user_id and user_id in user_twitter_cookies:
                # Crear archivo temporal de cookies para este usuario
                cookies_file = os.path.join(DOWNLOAD_DIR, f'cookies_{user_id}.txt')
                with open(cookies_file, 'w') as f:
                    f.write(user_twitter_cookies[user_id])
                ydl_opts['cookiefile'] = cookies_file
                logger.info(f"Usando cookies de usuario {user_id} para Twitter")
            else:
                # No usar cookies del navegador por defecto
                ydl_opts['cookiesfrombrowser'] = None

            # Forzar IPv4 para evitar problemas de conexi√≥n
            ydl_opts['source_address'] = '0.0.0.0'
        
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=True)
                filename = ydl.prepare_filename(info)
                
                # Si el archivo no existe con la extensi√≥n esperada, buscar variantes
                if not os.path.exists(filename):
                    base = os.path.splitext(filename)[0]
                    for ext in ['.mp4', '.mkv', '.webm', '.mov']:
                        alt_filename = base + ext
                        if os.path.exists(alt_filename):
                            filename = alt_filename
                            break
                
                # Verificar tama√±o y dividir si es necesario
                file_size = os.path.getsize(filename)
                parts = []
                
                if file_size > MAX_FILE_SIZE:
                    logger.info(f"Archivo muy grande ({file_size / (1024*1024):.2f}MB), dividiendo...")
                    parts = self.split_video(filename)
                else:
                    parts = [filename]
                
                return {
                    'success': True,
                    'filename': filename,
                    'parts': parts,
                    'title': info.get('title', 'video'),
                    'platform': platform,
                    'file_size': file_size,
                    'type': 'video'
                }
        except Exception as e:
            logger.error(f"Error descargando video: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }

    async def extract_audio(self, video_path):
        """Extrae el audio de un video"""
        try:
            audio_path = video_path.rsplit('.', 1)[0] + '.mp3'
            command = [
                'ffmpeg', '-i', video_path,
                '-vn', '-acodec', 'libmp3lame',
                '-ab', '192k', '-ar', '44100',
                '-y', audio_path
            ]
            subprocess.run(command, check=True, capture_output=True)
            return {'success': True, 'audio_path': audio_path}
        except Exception as e:
            logger.error(f"Error extrayendo audio: {str(e)}")
            return {'success': False, 'error': str(e)}

    async def transcribe_audio(self, audio_path):
        """Transcribe audio usando Whisper"""
        global WHISPER_MODEL
        try:
            # Cargar modelo si no est√° cargado
            if WHISPER_MODEL is None:
                logger.info("Cargando modelo Whisper (puede tomar unos minutos)...")
                WHISPER_MODEL = whisper.load_model("base")

            logger.info(f"Transcribiendo audio: {audio_path}")
            result = WHISPER_MODEL.transcribe(audio_path, language='es', fp16=False)

            return {
                'success': True,
                'text': result['text'],
                'language': result.get('language', 'es')
            }
        except Exception as e:
            logger.error(f"Error transcribiendo audio: {str(e)}")
            return {'success': False, 'error': str(e)}

downloader = VideoDownloader()

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /start"""
    welcome_message = """
üé• *Bot de Descarga y Transcripci√≥n de Videos*

Env√≠ame un enlace (o varios) de cualquiera de estas plataformas:
‚úÖ TikTok (sin marca de agua)
‚úÖ YouTube (hasta 1080p) - üîê *¬°Con login para evitar bloqueos!*
‚úÖ X (Twitter) - üîê *¬°Con soporte para cuentas privadas!*
‚úÖ Instagram (posts, reels e im√°genes)

*¬øQu√© puedo hacer?*
üì• Descargar videos
üìù Transcribir el audio a texto
üì•+üìù Ambas cosas
üîê Iniciar sesi√≥n en YouTube y X/Twitter

Simplemente env√≠a el enlace y tendr√°s *30 segundos* para elegir qu√© hacer.

*Comandos disponibles:*
/start - Mostrar este mensaje
/help - Ayuda
/platforms - Ver plataformas soportadas
/login_twitter - Iniciar sesi√≥n en X/Twitter
/logout_twitter - Cerrar sesi√≥n de X/Twitter
/login_youtube - Iniciar sesi√≥n en YouTube
/logout_youtube - Cerrar sesi√≥n de YouTube
    """
    await update.message.reply_text(welcome_message, parse_mode='Markdown')

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /help"""
    help_text = """
üìñ *Ayuda*

*C√≥mo usar:*
1. Copia el enlace del video o imagen que quieres descargar
2. Env√≠amelo directamente
3. Elige una opci√≥n en 30 segundos:
   üì• *Solo Descargar* - Recibe el video
   üìù *Solo Transcribir* - Recibe el texto del audio
   üì•+üìù *Ambos* - Recibe video y transcripci√≥n

*Caracter√≠sticas:*
‚úÖ Descarga de videos sin marca de agua (TikTok)
‚úÖ Transcripci√≥n autom√°tica de audio a texto
‚úÖ Soporte para m√∫ltiples idiomas
‚úÖ Divisi√≥n autom√°tica de transcripciones largas
‚úÖ üîê Login para YouTube (evita bloqueos de bot)
‚úÖ üîê Descarga de cuentas privadas de X/Twitter

*Login para YouTube:*
Si obtienes el error "Sign in to confirm you're not a bot":
1. Usa /login_youtube para iniciar sesi√≥n
2. Ingresa tu email y contrase√±a de Google
3. El bot guardar√° tus cookies de sesi√≥n
4. Ahora puedes descargar videos de YouTube sin problemas
5. Usa /logout_youtube cuando quieras cerrar sesi√≥n

*Cuentas Privadas de X/Twitter:*
Para descargar videos de cuentas privadas de X/Twitter:
1. Usa /login_twitter para iniciar sesi√≥n
2. Ingresa tu usuario y contrase√±a de X/Twitter
3. El bot guardar√° tus cookies de sesi√≥n
4. Ahora puedes descargar videos de cuentas privadas
5. Usa /logout_twitter cuando quieras cerrar sesi√≥n

*Limitaciones:*
- Videos >2GB se dividen en partes de ~1.9GB
- Algunos videos pueden tener restricciones de copyright
- La transcripci√≥n puede tomar varios minutos
- Las sesiones expiran despu√©s de un tiempo
- Cuentas con verificaci√≥n en 2 pasos pueden no funcionar

*Nota:* La transcripci√≥n usa IA para convertir el audio a texto con alta precisi√≥n.
    """
    await update.message.reply_text(help_text, parse_mode='Markdown')

async def platforms(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /platforms"""
    platforms_text = """
üåê *Plataformas Soportadas*

‚úÖ *TikTok*
   - tiktok.com
   - vm.tiktok.com
   - vt.tiktok.com (enlaces acortados)
   - Sin marca de agua (cuando est√° disponible)
   - Videos e im√°genes

‚úÖ *YouTube*
   - youtube.com
   - youtu.be
   - Hasta 1080p
   - Videos >2GB se dividen autom√°ticamente
   - üîê Usa /login_youtube si obtienes error de bot

‚úÖ *X (Twitter)*
   - twitter.com
   - x.com
   - Videos e im√°genes
   - üîê Soporta cuentas privadas con /login_twitter

‚úÖ *Instagram*
   - instagram.com
   - Posts, Reels e Im√°genes
   - Stories (si est√°n disponibles p√∫blicamente)

*Funciones especiales:*
üìπ Divisi√≥n autom√°tica de videos grandes
üñºÔ∏è Descarga de im√°genes en m√°xima calidad
üìé Procesamiento m√∫ltiple de enlaces
üîê Login para YouTube y X/Twitter
    """
    await update.message.reply_text(platforms_text, parse_mode='Markdown')

async def login_twitter_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Inicia el proceso de login para X/Twitter"""
    user_id = update.effective_user.id

    # Verificar si ya tiene sesi√≥n activa
    if user_id in user_twitter_cookies:
        keyboard = [
            [
                InlineKeyboardButton("‚úÖ S√≠, reemplazar", callback_data=f"replace_login_{user_id}"),
                InlineKeyboardButton("‚ùå Cancelar", callback_data=f"cancel_login_{user_id}")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            "‚ö†Ô∏è Ya tienes una sesi√≥n activa de X/Twitter.\n\n"
            "¬øDeseas reemplazarla con una nueva sesi√≥n?",
            reply_markup=reply_markup
        )
        return ConversationHandler.END

    await update.message.reply_text(
        "üîê *Login de X/Twitter*\n\n"
        "Para descargar videos de cuentas privadas, necesito tus credenciales de X/Twitter.\n\n"
        "‚ö†Ô∏è *Importante:*\n"
        "‚Ä¢ Tus credenciales solo se usan para obtener cookies de sesi√≥n\n"
        "‚Ä¢ No se guardan las contrase√±as, solo las cookies de sesi√≥n\n"
        "‚Ä¢ Las cookies expiran despu√©s de un tiempo\n"
        "‚Ä¢ Usa /logout_twitter para eliminar tu sesi√≥n\n\n"
        "üìù Por favor, env√≠a tu *nombre de usuario o email* de X/Twitter:\n\n"
        "_Env√≠a /cancel para cancelar_",
        parse_mode='Markdown'
    )
    return WAITING_USERNAME

async def receive_username(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Recibe el username y pide la contrase√±a"""
    username = update.message.text.strip()

    # Guardar username en context
    context.user_data['twitter_username'] = username

    await update.message.reply_text(
        f"‚úÖ Usuario recibido: `{username}`\n\n"
        "üîë Ahora env√≠a tu *contrase√±a* de X/Twitter:\n\n"
        "_La contrase√±a no se guardar√°, solo se usar√° para obtener las cookies de sesi√≥n_\n\n"
        "_Env√≠a /cancel para cancelar_",
        parse_mode='Markdown'
    )
    return WAITING_PASSWORD

async def receive_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Recibe la contrase√±a y realiza el login"""
    password = update.message.text.strip()
    username = context.user_data.get('twitter_username')
    user_id = update.effective_user.id

    # Eliminar el mensaje con la contrase√±a inmediatamente
    try:
        await update.message.delete()
    except:
        pass

    status_message = await update.effective_chat.send_message(
        "‚è≥ *Iniciando sesi√≥n en X/Twitter...*\n\n"
        "Esto puede tomar 30-60 segundos.\n"
        "Por favor espera...",
        parse_mode='Markdown'
    )

    # Generar cookies
    result = await generate_twitter_cookies(username, password)

    if result['success']:
        # Guardar cookies del usuario
        user_twitter_cookies[user_id] = result['cookies']

        await status_message.edit_text(
            "‚úÖ *¬°Login exitoso!*\n\n"
            "Ahora puedes descargar videos de cuentas privadas de X/Twitter.\n\n"
            "üîê Tu sesi√≥n est√° activa.\n"
            "üö™ Usa /logout_twitter para cerrar sesi√≥n.",
            parse_mode='Markdown'
        )
    else:
        await status_message.edit_text(
            "‚ùå *Error al iniciar sesi√≥n*\n\n"
            f"Error: {result['error']}\n\n"
            "Por favor verifica tus credenciales e intenta de nuevo con /login_twitter",
            parse_mode='Markdown'
        )

    # Limpiar datos del contexto
    context.user_data.clear()
    return ConversationHandler.END

async def cancel_login(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancela el proceso de login"""
    await update.message.reply_text(
        "‚ùå Proceso de login cancelado.\n\n"
        "Puedes intentar de nuevo en cualquier momento con /login_twitter"
    )
    context.user_data.clear()
    return ConversationHandler.END

async def logout_twitter(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cierra la sesi√≥n de X/Twitter"""
    user_id = update.effective_user.id

    if user_id in user_twitter_cookies:
        # Eliminar cookies del usuario
        del user_twitter_cookies[user_id]

        # Eliminar archivo de cookies temporal si existe
        cookies_file = os.path.join(DOWNLOAD_DIR, f'cookies_{user_id}.txt')
        if os.path.exists(cookies_file):
            try:
                os.remove(cookies_file)
            except:
                pass

        await update.message.reply_text(
            "‚úÖ *Sesi√≥n cerrada correctamente*\n\n"
            "Tu sesi√≥n de X/Twitter ha sido eliminada.\n\n"
            "Usa /login_twitter si necesitas volver a iniciar sesi√≥n.",
            parse_mode='Markdown'
        )
    else:
        await update.message.reply_text(
            "‚ÑπÔ∏è No tienes ninguna sesi√≥n activa de X/Twitter.\n\n"
            "Usa /login_twitter para iniciar sesi√≥n.",
            parse_mode='Markdown'
        )

async def login_youtube_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Inicia el proceso de login para YouTube"""
    user_id = update.effective_user.id

    # Verificar si ya tiene sesi√≥n activa
    if user_id in user_youtube_cookies:
        keyboard = [
            [
                InlineKeyboardButton("‚úÖ S√≠, reemplazar", callback_data=f"replace_yt_login_{user_id}"),
                InlineKeyboardButton("‚ùå Cancelar", callback_data=f"cancel_yt_login_{user_id}")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            "‚ö†Ô∏è Ya tienes una sesi√≥n activa de YouTube.\n\n"
            "¬øDeseas reemplazarla con una nueva sesi√≥n?",
            reply_markup=reply_markup
        )
        return ConversationHandler.END

    await update.message.reply_text(
        "üîê *Login de YouTube*\n\n"
        "Para evitar el error 'Sign in to confirm you're not a bot', necesito tus credenciales de Google/YouTube.\n\n"
        "‚ö†Ô∏è *Importante:*\n"
        "‚Ä¢ Tus credenciales solo se usan para obtener cookies de sesi√≥n\n"
        "‚Ä¢ No se guardan las contrase√±as, solo las cookies de sesi√≥n\n"
        "‚Ä¢ Las cookies expiran despu√©s de un tiempo\n"
        "‚Ä¢ Usa /logout_youtube para eliminar tu sesi√≥n\n\n"
        "üìù Por favor, env√≠a tu *email de Google*:\n\n"
        "_Env√≠a /cancel para cancelar_",
        parse_mode='Markdown'
    )
    return WAITING_YT_EMAIL

async def receive_yt_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Recibe el email de Google y pide la contrase√±a"""
    email = update.message.text.strip()

    # Guardar email en context
    context.user_data['youtube_email'] = email

    await update.message.reply_text(
        f"‚úÖ Email recibido: `{email}`\n\n"
        "üîë Ahora env√≠a tu *contrase√±a* de Google:\n\n"
        "_La contrase√±a no se guardar√°, solo se usar√° para obtener las cookies de sesi√≥n_\n\n"
        "_Env√≠a /cancel para cancelar_",
        parse_mode='Markdown'
    )
    return WAITING_YT_PASSWORD

async def receive_yt_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Recibe la contrase√±a y realiza el login de YouTube"""
    password = update.message.text.strip()
    email = context.user_data.get('youtube_email')
    user_id = update.effective_user.id

    # Eliminar el mensaje con la contrase√±a inmediatamente
    try:
        await update.message.delete()
    except:
        pass

    status_message = await update.effective_chat.send_message(
        "‚è≥ *Iniciando sesi√≥n en Google/YouTube...*\n\n"
        "Esto puede tomar 30-60 segundos.\n"
        "Por favor espera...",
        parse_mode='Markdown'
    )

    # Generar cookies
    result = await generate_youtube_cookies(email, password)

    if result['success']:
        # Guardar cookies del usuario
        user_youtube_cookies[user_id] = result['cookies']

        await status_message.edit_text(
            "‚úÖ *¬°Login exitoso!*\n\n"
            "Ahora puedes descargar videos de YouTube sin el error de bot.\n\n"
            "üîê Tu sesi√≥n est√° activa.\n"
            "üö™ Usa /logout_youtube para cerrar sesi√≥n.",
            parse_mode='Markdown'
        )
    else:
        await status_message.edit_text(
            "‚ùå *Error al iniciar sesi√≥n*\n\n"
            f"Error: {result['error']}\n\n"
            "‚ö†Ô∏è Si tienes verificaci√≥n en dos pasos habilitada, es posible que no funcione.\n"
            "Por favor verifica tus credenciales e intenta de nuevo con /login_youtube",
            parse_mode='Markdown'
        )

    # Limpiar datos del contexto
    context.user_data.clear()
    return ConversationHandler.END

async def cancel_youtube_login(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancela el proceso de login de YouTube"""
    await update.message.reply_text(
        "‚ùå Proceso de login cancelado.\n\n"
        "Puedes intentar de nuevo en cualquier momento con /login_youtube"
    )
    context.user_data.clear()
    return ConversationHandler.END

async def logout_youtube(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cierra la sesi√≥n de YouTube"""
    user_id = update.effective_user.id

    if user_id in user_youtube_cookies:
        # Eliminar cookies del usuario
        del user_youtube_cookies[user_id]

        # Eliminar archivo de cookies temporal si existe
        cookies_file = os.path.join(DOWNLOAD_DIR, f'youtube_cookies_{user_id}.txt')
        if os.path.exists(cookies_file):
            try:
                os.remove(cookies_file)
            except:
                pass

        await update.message.reply_text(
            "‚úÖ *Sesi√≥n cerrada correctamente*\n\n"
            "Tu sesi√≥n de YouTube ha sido eliminada.\n\n"
            "Usa /login_youtube si necesitas volver a iniciar sesi√≥n.",
            parse_mode='Markdown'
        )
    else:
        await update.message.reply_text(
            "‚ÑπÔ∏è No tienes ninguna sesi√≥n activa de YouTube.\n\n"
            "Usa /login_youtube para iniciar sesi√≥n.",
            parse_mode='Markdown'
        )

async def handle_login_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja los callbacks de los botones de login (Twitter y YouTube)"""
    query = update.callback_query
    await query.answer()

    callback_data = query.data

    # Manejar callbacks de YouTube
    if 'yt_login' in callback_data:
        parts = callback_data.split('_')
        action = parts[0]  # 'replace' o 'cancel'
        user_id = int(parts[-1])

        # Verificar que el usuario que presion√≥ el bot√≥n es el correcto
        if query.from_user.id != user_id:
            await query.answer("‚ö†Ô∏è Este bot√≥n no es para ti", show_alert=True)
            return

        if action == "replace":
            await query.edit_message_text(
                "üîê *Login de YouTube*\n\n"
                "üìù Por favor, env√≠a tu *email de Google*:\n\n"
                "_Env√≠a /cancel para cancelar_",
                parse_mode='Markdown'
            )
            return WAITING_YT_EMAIL
        elif action == "cancel":
            await query.edit_message_text(
                "‚ùå Proceso cancelado.\n\n"
                "Tu sesi√≥n anterior sigue activa."
            )
            return ConversationHandler.END

    # Manejar callbacks de Twitter (c√≥digo original)
    else:
        action, user_id_str = callback_data.split('_', 2)[0:2]
        user_id = int(user_id_str.split('_')[-1])

        # Verificar que el usuario que presion√≥ el bot√≥n es el correcto
        if query.from_user.id != user_id:
            await query.answer("‚ö†Ô∏è Este bot√≥n no es para ti", show_alert=True)
            return

        if action == "replace":
            await query.edit_message_text(
                "üîê *Login de X/Twitter*\n\n"
                "üìù Por favor, env√≠a tu *nombre de usuario o email* de X/Twitter:\n\n"
                "_Env√≠a /cancel para cancelar_",
                parse_mode='Markdown'
            )
            return WAITING_USERNAME
        elif action == "cancel":
            await query.edit_message_text(
                "‚ùå Proceso cancelado.\n\n"
                "Tu sesi√≥n anterior sigue activa."
            )
            return ConversationHandler.END

async def handle_url(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja URLs enviados por el usuario"""
    url = update.message.text.strip()

    # Validar que sea un URL
    url_pattern = re.compile(
        r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'
    )

    if not url_pattern.match(url):
        await update.message.reply_text(
            "‚ùå No se encontraron enlaces v√°lidos.\n"
            "Env√≠a uno o m√°s enlaces de video/imagen."
        )
        return

    # Detectar plataforma
    platform = downloader.get_platform(url)
    if not platform:
        await update.message.reply_text(
            "‚ùå Ninguno de los enlaces es de una plataforma soportada.\n"
            "Usa /platforms para ver las plataformas disponibles."
        )
        return

    # Guardar URL en el almac√©n temporal (expira en 30 segundos)
    user_id = update.effective_user.id
    expiration_time = datetime.now() + timedelta(seconds=30)
    user_data_store[user_id] = {
        'url': url,
        'platform': platform,
        'expires_at': expiration_time
    }

    # Crear botones inline
    keyboard = [
        [
            InlineKeyboardButton("üì• Solo Descargar", callback_data=f"download_{user_id}"),
            InlineKeyboardButton("üìù Solo Transcribir", callback_data=f"transcribe_{user_id}")
        ],
        [
            InlineKeyboardButton("üì•+üìù Descargar y Transcribir", callback_data=f"both_{user_id}")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        f"üé¨ Video detectado de *{platform.upper()}*\n\n"
        "¬øQu√© deseas hacer con este video?\n"
        "‚è±Ô∏è _Tienes 30 segundos para elegir_",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja los callbacks de los botones inline"""
    query = update.callback_query
    await query.answer()

    # Parsear el callback data
    action, user_id_str = query.data.split('_', 1)
    user_id = int(user_id_str)

    # Verificar que el usuario que presion√≥ el bot√≥n es el correcto
    if query.from_user.id != user_id:
        await query.answer("‚ö†Ô∏è Este bot√≥n no es para ti", show_alert=True)
        return

    # Verificar si los datos a√∫n est√°n disponibles
    if user_id not in user_data_store:
        await query.edit_message_text(
            "‚ùå El tiempo para seleccionar ha expirado (30 segundos).\n"
            "Por favor, env√≠a el enlace nuevamente."
        )
        return

    user_data = user_data_store[user_id]

    # Verificar expiraci√≥n
    if datetime.now() > user_data['expires_at']:
        del user_data_store[user_id]
        await query.edit_message_text(
            "‚ùå El tiempo para seleccionar ha expirado (30 segundos).\n"
            "Por favor, env√≠a el enlace nuevamente."
        )
        return

    url = user_data['url']
    platform = user_data['platform']
    chat_id = query.message.chat_id

    # Limpiar datos del almac√©n
    del user_data_store[user_id]

    # Procesar seg√∫n la acci√≥n seleccionada
    if action == 'download':
        await process_download_only(query, url, platform, chat_id)
    elif action == 'transcribe':
        await process_transcribe_only(query, url, platform, chat_id)
    elif action == 'both':
        await process_both(query, url, platform, chat_id)

async def process_download_only(query, url, platform, chat_id):
    """Procesa solo la descarga del video"""
    user_id = query.from_user.id

    await query.edit_message_text(
        f"‚è≥ Descargando video de *{platform.upper()}*...\n"
        "Esto puede tomar unos momentos.",
        parse_mode='Markdown'
    )

    try:
        # Descargar video
        result = await downloader.download_video(url, chat_id, user_id=user_id)

        if not result['success']:
            await query.edit_message_text(
                f"‚ùå Error al descargar el video:\n`{result['error']}`",
                parse_mode='Markdown'
            )
            return

        # Enviar video
        await query.edit_message_text("üì§ Enviando video...")

        with open(result['filename'], 'rb') as video_file:
            caption = f"‚úÖ *{result['title']}*\n\nüåê Plataforma: {result['platform'].upper()}"
            if result['platform'] == 'tiktok':
                caption += "\nüö´ Sin marca de agua"

            await query.message.reply_video(
                video=video_file,
                caption=caption,
                parse_mode='Markdown',
                supports_streaming=True
            )

        # Eliminar archivo temporal
        try:
            os.remove(result['filename'])
        except:
            pass

        # Eliminar mensaje de procesamiento
        await query.delete_message()

    except Exception as e:
        logger.error(f"Error procesando video: {str(e)}")
        await query.edit_message_text(
            f"‚ùå Error al procesar el video:\n`{str(e)}`\n\n"
            "El video puede ser muy grande o tener restricciones.",
            parse_mode='Markdown'
        )

async def process_transcribe_only(query, url, platform, chat_id):
    """Procesa solo la transcripci√≥n del video"""
    user_id = query.from_user.id

    await query.edit_message_text(
        f"‚è≥ Descargando y transcribiendo video de *{platform.upper()}*...\n"
        "üéôÔ∏è Esto puede tomar varios minutos.",
        parse_mode='Markdown'
    )

    try:
        # Descargar video
        result = await downloader.download_video(url, chat_id, user_id=user_id)

        if not result['success']:
            await query.edit_message_text(
                f"‚ùå Error al descargar el video:\n`{result['error']}`",
                parse_mode='Markdown'
            )
            return

        # Extraer audio
        await query.edit_message_text("üéµ Extrayendo audio del video...")
        audio_result = await downloader.extract_audio(result['filename'])

        if not audio_result['success']:
            await query.edit_message_text(
                f"‚ùå Error al extraer audio:\n`{audio_result['error']}`",
                parse_mode='Markdown'
            )
            # Limpiar archivo de video
            try:
                os.remove(result['filename'])
            except:
                pass
            return

        # Transcribir audio
        await query.edit_message_text(
            "üìù Transcribiendo audio...\n"
            "‚è±Ô∏è Esto puede tomar varios minutos dependiendo de la duraci√≥n del video."
        )
        transcription_result = await downloader.transcribe_audio(audio_result['audio_path'])

        if not transcription_result['success']:
            await query.edit_message_text(
                f"‚ùå Error al transcribir:\n`{transcription_result['error']}`",
                parse_mode='Markdown'
            )
            # Limpiar archivos
            try:
                os.remove(result['filename'])
                os.remove(audio_result['audio_path'])
            except:
                pass
            return

        # Enviar transcripci√≥n
        transcription_text = f"üìù *Transcripci√≥n de: {result['title']}*\n\n"
        transcription_text += f"üåê Plataforma: {platform.upper()}\n"
        transcription_text += f"üó£Ô∏è Idioma detectado: {transcription_result['language']}\n\n"
        transcription_text += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n"
        transcription_text += transcription_result['text']

        # Telegram tiene l√≠mite de 4096 caracteres por mensaje
        if len(transcription_text) > 4000:
            # Enviar en m√∫ltiples mensajes
            await query.message.reply_text(
                f"üìù *Transcripci√≥n de: {result['title']}*\n\n"
                f"üåê Plataforma: {platform.upper()}\n"
                f"üó£Ô∏è Idioma: {transcription_result['language']}\n\n"
                "‚ö†Ô∏è La transcripci√≥n es muy larga, se enviar√° en varios mensajes.",
                parse_mode='Markdown'
            )

            # Dividir el texto en chunks
            text_chunks = [transcription_result['text'][i:i+4000]
                          for i in range(0, len(transcription_result['text']), 4000)]

            for i, chunk in enumerate(text_chunks, 1):
                await query.message.reply_text(
                    f"üìÑ Parte {i}/{len(text_chunks)}:\n\n{chunk}"
                )
        else:
            await query.message.reply_text(transcription_text, parse_mode='Markdown')

        # Limpiar archivos
        try:
            os.remove(result['filename'])
            os.remove(audio_result['audio_path'])
        except:
            pass

        await query.delete_message()

    except Exception as e:
        logger.error(f"Error en transcripci√≥n: {str(e)}")
        await query.edit_message_text(
            f"‚ùå Error al procesar:\n`{str(e)}`",
            parse_mode='Markdown'
        )

async def process_both(query, url, platform, chat_id):
    """Procesa descarga y transcripci√≥n del video"""
    user_id = query.from_user.id

    await query.edit_message_text(
        f"‚è≥ Descargando video de *{platform.upper()}*...\n"
        "üì• Descargando y üìù Transcribiendo",
        parse_mode='Markdown'
    )

    video_path = None
    audio_path = None

    try:
        # Descargar video
        result = await downloader.download_video(url, chat_id, user_id=user_id)

        if not result['success']:
            await query.edit_message_text(
                f"‚ùå Error al descargar el video:\n`{result['error']}`",
                parse_mode='Markdown'
            )
            return

        video_path = result['filename']

        # Enviar video primero
        await query.edit_message_text("üì§ Enviando video...")

        with open(result['filename'], 'rb') as video_file:
            caption = f"‚úÖ *{result['title']}*\n\nüåê Plataforma: {result['platform'].upper()}"
            if result['platform'] == 'tiktok':
                caption += "\nüö´ Sin marca de agua"

            await query.message.reply_video(
                video=video_file,
                caption=caption,
                parse_mode='Markdown',
                supports_streaming=True
            )

        # Extraer audio
        await query.edit_message_text("üéµ Extrayendo audio para transcripci√≥n...")
        audio_result = await downloader.extract_audio(result['filename'])

        if not audio_result['success']:
            await query.edit_message_text(
                "‚úÖ Video enviado correctamente.\n\n"
                f"‚ùå Error al extraer audio para transcripci√≥n:\n`{audio_result['error']}`",
                parse_mode='Markdown'
            )
            try:
                os.remove(result['filename'])
            except:
                pass
            return

        audio_path = audio_result['audio_path']

        # Transcribir audio
        await query.edit_message_text(
            "üìù Transcribiendo audio...\n"
            "‚è±Ô∏è Esto puede tomar varios minutos."
        )
        transcription_result = await downloader.transcribe_audio(audio_result['audio_path'])

        if not transcription_result['success']:
            await query.edit_message_text(
                "‚úÖ Video enviado correctamente.\n\n"
                f"‚ùå Error al transcribir:\n`{transcription_result['error']}`",
                parse_mode='Markdown'
            )
            try:
                os.remove(result['filename'])
                os.remove(audio_result['audio_path'])
            except:
                pass
            return

        # Enviar transcripci√≥n
        transcription_text = f"üìù *Transcripci√≥n de: {result['title']}*\n\n"
        transcription_text += f"üåê Plataforma: {platform.upper()}\n"
        transcription_text += f"üó£Ô∏è Idioma detectado: {transcription_result['language']}\n\n"
        transcription_text += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n"
        transcription_text += transcription_result['text']

        if len(transcription_text) > 4000:
            await query.message.reply_text(
                f"üìù *Transcripci√≥n de: {result['title']}*\n\n"
                f"üåê Plataforma: {platform.upper()}\n"
                f"üó£Ô∏è Idioma: {transcription_result['language']}\n\n"
                "‚ö†Ô∏è La transcripci√≥n es muy larga, se enviar√° en varios mensajes.",
                parse_mode='Markdown'
            )

            text_chunks = [transcription_result['text'][i:i+4000]
                          for i in range(0, len(transcription_result['text']), 4000)]

            for i, chunk in enumerate(text_chunks, 1):
                await query.message.reply_text(
                    f"üìÑ Parte {i}/{len(text_chunks)}:\n\n{chunk}"
                )
        else:
            await query.message.reply_text(transcription_text, parse_mode='Markdown')

        await query.delete_message()

    except Exception as e:
        logger.error(f"Error procesando video completo: {str(e)}")
        await query.edit_message_text(
            f"‚ùå Error al procesar:\n`{str(e)}`",
            parse_mode='Markdown'
        )
    finally:
        # Limpiar archivos
        try:
            if video_path:
                os.remove(video_path)
            if audio_path:
                os.remove(audio_path)
        except:
            pass

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja errores"""
    logger.error(f"Update {update} caused error {context.error}")

def main():
    """Funci√≥n principal"""
    if not BOT_TOKEN:
        logger.error("TELEGRAM_BOT_TOKEN no est√° configurado")
        return

    # Crear aplicaci√≥n
    application = Application.builder().token(BOT_TOKEN).build()

    # ConversationHandler para login de Twitter
    login_conversation = ConversationHandler(
        entry_points=[CommandHandler('login_twitter', login_twitter_start)],
        states={
            WAITING_USERNAME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_username)
            ],
            WAITING_PASSWORD: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_password)
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel_login)],
        allow_reentry=True
    )

    # ConversationHandler para login de YouTube
    youtube_login_conversation = ConversationHandler(
        entry_points=[CommandHandler('login_youtube', login_youtube_start)],
        states={
            WAITING_YT_EMAIL: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_yt_email)
            ],
            WAITING_YT_PASSWORD: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_yt_password)
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel_youtube_login)],
        allow_reentry=True
    )

    # Handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("platforms", platforms))
    application.add_handler(CommandHandler("logout_twitter", logout_twitter))
    application.add_handler(CommandHandler("logout_youtube", logout_youtube))
    application.add_handler(login_conversation)
    application.add_handler(youtube_login_conversation)
    application.add_handler(CallbackQueryHandler(button_callback, pattern=r'^(download|transcribe|both)_\d+$'))
    application.add_handler(CallbackQueryHandler(handle_login_callback, pattern=r'^(replace|cancel)_login_\d+$'))
    application.add_handler(CallbackQueryHandler(handle_login_callback, pattern=r'^(replace|cancel)_yt_login_\d+$'))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_url))
    application.add_error_handler(error_handler)

    # Iniciar bot
    logger.info("Bot iniciado...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
